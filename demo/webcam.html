<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Motion Estimation Demo</title>
</head>
<body>
  <div>
    <canvas id=vis width=640 height=480></canvas>
    <video id=camera width=640 height=480 autoplay></video>
  </div>

  <script src="../node_modules/@tensorflow/tfjs/dist/tf.min.js"></script>
  <script>
    // get access to the canvas to draw motion vectors over the video
    var canvas = vis.getContext('2d', { alpha: false })

    // ask browser to stream the webcam in to the <video> element
    navigator.mediaDevices.getUserMedia({video: true})
      .then((stream)=> { camera.srcObject = stream; mainLoop(); })
      .catch((error)=> alert(`getUserMedia Error: ${error}`))

    // persistant to store the last webcam image as a tensorflow tensor
    var lastImageTensor;
    // loop that runs watching the webcam feed and processing it through tensorflow
    var mainLoop = async function() {
      // keep track of if the webcam has pushed a new frame since the last time we read the video buffer
      let isNewFrame = false
      // fetch the video frame and check if it's content has changed
      let thisImageTensor = tf.tidy(()=> {
        // grab a tensor snapshot of the current webcam feed
        let image = tf.fromPixels(camera)
        
        // verify we have an old image to compare to
        if (lastImageTensor) {
          // check if the frames are the different
          isNewFrame = !tf.all(tf.equal(lastImageTensor, image)).get()
        } else {
          // if there's no last frame, then this one's definitely new! the first is always new!
          isNewFrame = true
        }
        // return frame out so it becomes thisImageTensor
        return image
      })
      
      // when a new frame comes in, we can do some processing!
      if (isNewFrame) {
        // console.log("new frame!")
        // draw the new frame to our visualisation canvas
        await tf.toPixels(thisImageTensor, vis)

        // clear out memory from old frame and make this frame in to the old frame now we're done
        if (lastImageTensor) lastImageTensor.dispose()
        lastImageTensor = thisImageTensor
      } else {
        // no new frame? either use it to fill the lastImageTensor variable, or clear out the memory
        if (!lastImageTensor) lastImageTensor = thisImageTensor
        else thisImageTensor.dispose()
      }

      // request the browser run this function again next time it gets ready to refresh the screen
      requestAnimationFrame(mainLoop)
    }
  </script>
</body>
</html>